package vimebu

import (
	"github.com/VictoriaMetrics/metrics"
)

// GetOrCreateFloatCounter calls [metrics.GetOrCreateFloatCounter] using the Builder's accumulated string as argument.
func (b *Builder) GetOrCreateFloatCounter() *metrics.FloatCounter {
	return metrics.GetOrCreateFloatCounter(b.String())
}

// GetOrCreateFloatCounterInSet calls [metrics.Set.GetOrCreateFloatCounter] using the Builder's accumulated string as argument.
func (b *Builder) GetOrCreateFloatCounterInSet(set *metrics.Set) *metrics.FloatCounter {
	return set.GetOrCreateFloatCounter(b.String())
}

// NewFloatCounter calls [metrics.NewFloatCounter] using the Builder's accumulated string as argument.
func (b *Builder) NewFloatCounter() *metrics.FloatCounter {
	return metrics.NewFloatCounter(b.String())
}

// NewFloatCounterInSet calls [metrics.Set.NewFloatCounter] using the Builder's accumulated string as argument.
func (b *Builder) NewFloatCounterInSet(set *metrics.Set) *metrics.FloatCounter {
	return set.NewFloatCounter(b.String())
}

// Methods with validation.

// ValidateGetOrCreateFloatCounter calls [metrics.GetOrCreateFloatCounter] using the Builder's accumulated string as argument.
//
// It returns an error if the provided metric is invalid, as per the [metrics.ValidateMetric] function.
//
// This is useful when you want to avoid the runtime panic generated by VM when a metric is invalid.
func (b *Builder) ValidateGetOrCreateFloatCounter() (*metrics.FloatCounter, error) {
	return b.ValidateGetOrCreateFloatCounterInSet(defaultSet)
}

// ValidateGetOrCreateFloatCounterInSet calls [metrics.Set.GetOrCreateFloatCounter] using the Builder's accumulated string as argument.
//
// It returns an error if the provided metric is invalid, as per the [metrics.ValidateMetric] function.
//
// This is useful when you want to avoid the runtime panic generated by VM when a metric is invalid.
func (b *Builder) ValidateGetOrCreateFloatCounterInSet(set *metrics.Set) (*metrics.FloatCounter, error) {
	name := b.String()
	if err := validateMetric(name); err != nil {
		return nil, err
	}
	return set.GetOrCreateFloatCounter(name), nil
}

// ValidateNewFloatCounter calls [metrics.NewFloatCounter] using the Builder's accumulated string as argument.
//
// It returns an error if the provided metric is invalid, as per the [metrics.ValidateMetric] function.
//
// This is useful when you want to avoid the runtime panic generated by VM when a metric is invalid.
func (b *Builder) ValidateNewFloatCounter() (*metrics.FloatCounter, error) {
	return b.ValidateNewFloatCounterInSet(defaultSet)
}

// ValidateNewFloatCounterInSet calls [metrics.Set.NewFloatCounter] using the Builder's accumulated string as argument.
//
// It returns an error if the provided metric is invalid, as per the [metrics.ValidateMetric] function.
//
// This is useful when you want to avoid the runtime panic generated by VM when a metric is invalid.
func (b *Builder) ValidateNewFloatCounterInSet(set *metrics.Set) (*metrics.FloatCounter, error) {
	name := b.String()
	if err := validateMetric(name); err != nil {
		return nil, err
	}
	return set.NewFloatCounter(name), nil
}
