package vimebu

import (
	"fmt"

	"github.com/VictoriaMetrics/metrics"
)

// GetOrCreateFloatCounter calls [metrics.GetOrCreateFloatCounter] using the Builder's accumulated string as argument.
func (b *Builder) GetOrCreateFloatCounter() *metrics.FloatCounter {
	return metrics.GetOrCreateFloatCounter(b.String())
}

// GetOrCreateFloatCounterInSet calls [metrics.Set.GetOrCreateFloatCounter] using the Builder's accumulated string as argument.
func (b *Builder) GetOrCreateFloatCounterInSet(set *metrics.Set) *metrics.FloatCounter {
	return set.GetOrCreateFloatCounter(b.String())
}

// NewFloatCounter calls [metrics.NewFloatCounter] using the Builder's accumulated string as argument.
func (b *Builder) NewFloatCounter() *metrics.FloatCounter {
	return metrics.NewFloatCounter(b.String())
}

// NewFloatCounterInSet calls [metrics.Set.NewFloatCounter] using the Builder's accumulated string as argument.
func (b *Builder) NewFloatCounterInSet(set *metrics.Set) *metrics.FloatCounter {
	return set.NewFloatCounter(b.String())
}

// Methods with validation.

func (b *Builder) validateFloatCounter(set *metrics.Set, new bool) (*metrics.FloatCounter, error) {
	name := b.String()
	if err := metrics.ValidateMetric(name); err != nil {
		return nil, fmt.Errorf("invalid metric, err: %w", err)
	}
	if new {
		return set.NewFloatCounter(name), nil
	}
	return set.GetOrCreateFloatCounter(name), nil
}

// ValidateGetOrCreateFloatCounter calls [metrics.GetOrCreateFloatCounter] using the Builder's accumulated string as argument.
//
// It returns an error if the provided metric is invalid, as per the [metrics.ValidateMetric] function.
//
// This is useful when you want to avoid the runtime panic generated by VM when a metric is invalid.
func (b *Builder) ValidateGetOrCreateFloatCounter() (*metrics.FloatCounter, error) {
	return b.validateFloatCounter(metrics.GetDefaultSet(), false)
}

// ValidateGetOrCreateFloatCounterInSet calls [metrics.Set.GetOrCreateFloatCounter] using the Builder's accumulated string as argument.
//
// It returns an error if the provided metric is invalid, as per the [metrics.ValidateMetric] function.
//
// This is useful when you want to avoid the runtime panic generated by VM when a metric is invalid.
func (b *Builder) ValidateGetOrCreateFloatCounterInSet(set *metrics.Set) (*metrics.FloatCounter, error) {
	return b.validateFloatCounter(set, false)
}

// ValidateNewFloatCounter calls [metrics.NewFloatCounter] using the Builder's accumulated string as argument.
//
// It returns an error if the provided metric is invalid, as per the [metrics.ValidateMetric] function.
//
// This is useful when you want to avoid the runtime panic generated by VM when a metric is invalid.
func (b *Builder) ValidateNewFloatCounter() (*metrics.FloatCounter, error) {
	return b.validateFloatCounter(metrics.GetDefaultSet(), true)
}

// ValidateNewFloatCounterInSet calls [metrics.Set.NewFloatCounter] using the Builder's accumulated string as argument.
//
// It returns an error if the provided metric is invalid, as per the [metrics.ValidateMetric] function.
//
// This is useful when you want to avoid the runtime panic generated by VM when a metric is invalid.
func (b *Builder) ValidateNewFloatCounterInSet(set *metrics.Set) (*metrics.FloatCounter, error) {
	return b.validateFloatCounter(set, true)
}
